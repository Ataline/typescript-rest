{"version":3,"sources":["../../src/lib/server.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAGb,kBAAgB;AAChB,uDAAkD;AAMlD;IAAA;IAkFA,CAAC;IA9EO,oBAAa,GAApB,UAAqB,MAAsB;QAAE,eAAQ;aAAR,UAAQ,EAAR,qBAAQ,EAAR,IAAQ;YAAR,8BAAQ;;QACpD,IAAI,aAAa,GAAmB,IAAI,iCAAc,CAAC,MAAM,CAAC,CAAC;QAC/D,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAKM,eAAQ,GAAf;QACC,IAAI,MAAM,GAAG,IAAI,KAAK,EAAU,CAAC;QACjC,iCAAc,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,UAAA,KAAK;YACtC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;IAMM,qBAAc,GAArB,UAAsB,IAAY;QACjC,IAAI,MAAM,GAAG,IAAI,KAAK,EAAc,CAAC;QACrC,iCAAc,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAA,KAAK;YAChD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;IAOM,uBAAgB,GAAvB,UAAwB,MAAc;QACrC,iCAAc,CAAC,aAAa,GAAG,MAAM,CAAC;IACvC,CAAC;IAaM,wBAAiB,GAAxB,UAAyB,OAAgC;QACxD,iCAAc,CAAC,cAAc,GAAG,OAAO,CAAC;IACzC,CAAC;IAMM,kBAAW,GAAlB,UAAmB,IAAY;QAC9B,iCAAc,CAAC,QAAQ,GAAG,IAAI,CAAC;IAChC,CAAC;IAMM,oBAAa,GAApB,UAAqB,MAC6C;QACjE,iCAAc,CAAC,UAAU,GAAG,MAAM,CAAC;IACpC,CAAC;IAMM,oBAAa,GAApB,UAAqB,KAAa;QACjC,iCAAc,CAAC,UAAU,GAAG,KAAK,CAAC;IACnC,CAAC;IACF,aAAC;AAAD,CAlFA,AAkFC,IAAA;AAlFY,wBAAM","file":"server.js","sourcesContent":["\"use strict\";\n\nimport * as express from \"express\";\nimport \"multer\"; \nimport {InternalServer} from \"./server-container\"; \nimport {HttpMethod} from \"./server-types\"; \n\n/**\n * The Http server main class. \n */\nexport class Server {\n\t/**\n\t * Create the routes for all classes decorated with our decorators\n\t */\n\tstatic buildServices(router: express.Router, ...types) {\n\t\tlet iternalServer: InternalServer = new InternalServer(router);\n\t\titernalServer.buildServices(types);\n\t}\n\n\t/**\n\t * Return all paths accepted by the Server\n\t */\n\tstatic getPaths(): Array<string> {\n\t\tlet result = new Array<string>();\n\t\tInternalServer.getPaths().forEach(value=>{\n\t\t\tresult.push(value);\n\t\t});\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return the set oh HTTP verbs configured for the given path\n\t * @param path The path to search HTTP verbs\n\t */\n\tstatic getHttpMethods(path: string): Array<HttpMethod> {\n\t\tlet result = new Array<HttpMethod>();\n\t\tInternalServer.getHttpMethods(path).forEach(value=>{\n\t\t\tresult.push(value);\n\t\t});\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * A string used for signing cookies. This is optional and if not specified, \n\t * will not parse signed cookies.\n\t * @param secret the secret used to sign\n\t */\n\tstatic setCookiesSecret(secret: string) {\n\t\tInternalServer.cookiesSecret = secret;\n\t}\n\n\t/**\n\t * Specifies a function that will be used to decode a cookie's value. \n\t * This function can be used to decode a previously-encoded cookie value \n\t * into a JavaScript string.\n\t * The default function is the global decodeURIComponent, which will decode \n\t * any URL-encoded sequences into their byte representations.\n\t * \n\t * NOTE: if an error is thrown from this function, the original, non-decoded \n\t * cookie value will be returned as the cookie's value.\n\t * @param decoder The decoder function\n\t */\n\tstatic setCookiesDecoder(decoder: (val: string) => string) {\n\t\tInternalServer.cookiesDecoder = decoder;\n\t}\n\n\t/**\n\t * Set where to store the uploaded files\n\t * @param dest Destination folder\n\t */\n\tstatic setFileDest(dest: string) {\n\t\tInternalServer.fileDest = dest;\n\t}\n\n\t/**\n\t * Set a Function to control which files are accepted to upload\n\t * @param filter The filter function\n\t */\n\tstatic setFileFilter(filter: (req: Express.Request, file: Express.Multer.File, \n\t\t\t\t\tcallback: (error: Error, acceptFile: boolean) => void) => void) {\n\t\tInternalServer.fileFilter = filter;\n\t}\n\n\t/**\n\t * Set the limits of uploaded data\n\t * @param limit The data limit\n\t */\n\tstatic setFileLimits(limit: number) {\n\t\tInternalServer.fileLimits = limit;\n\t}\n}\n"]}